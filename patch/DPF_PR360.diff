diff --git a/distrho/DistrhoUIMain.cpp b/distrho/DistrhoUIMain.cpp
index aeeade58..13480408 100644
--- a/distrho/DistrhoUIMain.cpp
+++ b/distrho/DistrhoUIMain.cpp
@@ -14,6 +14,13 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include "src/DistrhoDefines.h"
+#if defined(DISTRHO_OS_MAC)
+// Allow referencing CoreFoundation from DistrhoUIVST3.cpp. Include must appear
+// before DGL headers otherwise compiler fails on ambiguous 'Point' definition.
+# include <CoreFoundation/CoreFoundation.h>
+#endif
+
 #include "src/DistrhoUI.cpp"
 
 #if defined(DISTRHO_PLUGIN_TARGET_CARLA)
diff --git a/distrho/src/DistrhoUIVST3.cpp b/distrho/src/DistrhoUIVST3.cpp
index d0e8422c..b8828acb 100644
--- a/distrho/src/DistrhoUIVST3.cpp
+++ b/distrho/src/DistrhoUIVST3.cpp
@@ -21,6 +21,10 @@
 #include "travesty/host.h"
 #include "travesty/view.h"
 
+#if defined(DISTRHO_OS_WINDOWS)
+#include <winuser.h>
+#endif
+
 /* TODO items:
  * - mousewheel event
  * - key down/up events
@@ -32,6 +36,10 @@
 # define DPF_VST3_USING_HOST_RUN_LOOP
 #endif
 
+#if defined(DISTRHO_OS_WINDOWS)
+# define DPF_VST3_WIN32_TIMER_ID 1
+#endif
+
 #ifndef DPF_VST3_TIMER_INTERVAL
 # define DPF_VST3_TIMER_INTERVAL 16 /* ~60 fps */
 #endif
@@ -127,6 +135,13 @@ class UIVst3
           fScaleFactor(scaleFactor),
           fIsResizingFromPlugin(false),
           fIsResizingFromHost(willResizeFromHost),
+#if defined(DISTRHO_OS_MAC)
+          fTimerPtr(nullptr),
+#endif
+#if defined(DISTRHO_OS_WINDOWS)
+          fTimerHwnd(nullptr),
+          fTimerWindowClassName(nullptr),
+#endif
           fUI(this, winId, sampleRate,
               editParameterCallback,
               setParameterCallback,
@@ -142,8 +157,12 @@ class UIVst3
 
     ~UIVst3()
     {
-#if !DISTRHO_PLUGIN_HAS_EXTERNAL_UI && (defined(DISTRHO_OS_MAC) || defined(DISTRHO_OS_WINDOWS))
+#if defined(DISTRHO_OS_MAC) || defined(DISTRHO_OS_WINDOWS)
+# if DISTRHO_PLUGIN_HAS_EXTERNAL_UI
+        nativeIdleTimerDestroy();
+# else
         fUI.removeIdleCallbackForVST3(this);
+# endif
 #endif
         if (fConnection != nullptr)
             disconnect();
@@ -168,8 +187,12 @@ class UIVst3
         if (fConnection != nullptr)
             connect(fConnection);
 
-#if !DISTRHO_PLUGIN_HAS_EXTERNAL_UI && (defined(DISTRHO_OS_MAC) || defined(DISTRHO_OS_WINDOWS))
+#if defined(DISTRHO_OS_MAC) || defined(DISTRHO_OS_WINDOWS)
+# if DISTRHO_PLUGIN_HAS_EXTERNAL_UI
+        nativeIdleTimerCreate(DPF_VST3_TIMER_INTERVAL);
+# else
         fUI.addIdleCallbackForVST3(this, DPF_VST3_TIMER_INTERVAL);
+# endif
 #endif
     }
 
@@ -538,6 +561,15 @@ class UIVst3
     bool fIsResizingFromPlugin;
     bool fIsResizingFromHost;
 
+    // Native timer support
+#if defined(DISTRHO_OS_MAC)
+    CFRunLoopTimerRef fTimerPtr;
+#endif
+#if defined(DISTRHO_OS_WINDOWS)
+    HWND fTimerHwnd;
+    LPSTR fTimerWindowClassName;
+#endif
+
     // Plugin UI (after VST3 stuff so the UI can call into us during its constructor)
     UIExporter fUI;
 
@@ -712,6 +744,71 @@ class UIVst3
         ((UIVst3*)ptr)->setState(key, value);
     }
 #endif
+
+#if DISTRHO_PLUGIN_HAS_EXTERNAL_UI
+# if defined(DISTRHO_OS_MAC)
+    void nativeIdleTimerCreate(const uint timerFrequencyInMs)
+    {
+        const CFTimeInterval t = static_cast<double>(timerFrequencyInMs) / 1000.0;
+        CFRunLoopTimerContext ctx = {};
+        ctx.info = this;
+        fTimerPtr = CFRunLoopTimerCreate(kCFAllocatorDefault, CFAbsoluteTimeGetCurrent() + t, t, 0, 0,
+            UIVst3::nativeIdleTimerCallback, &ctx);
+        CFRunLoopAddTimer(CFRunLoopGetCurrent(), fTimerPtr, kCFRunLoopCommonModes);
+    }
+
+    void nativeIdleTimerDestroy()
+    {
+        CFRunLoopRemoveTimer(CFRunLoopGetCurrent(), fTimerPtr, kCFRunLoopCommonModes);
+        CFRelease(fTimerPtr);
+    }
+
+    static void nativeIdleTimerCallback(CFRunLoopTimerRef timer, void *info)
+    {
+        reinterpret_cast<UIVst3*>(info)->onTimer();
+    }
+# elif defined(DISTRHO_OS_WINDOWS)
+    void nativeIdleTimerCreate(const uint timerFrequencyInMs)
+    {
+        // We cannot assume anything about the native parent window passed as a
+        // parameter (winId) to the UIVst3 constructor because we do not own it.
+        // These parent windows have class names like 'reaperPluginHostWrapProc'
+        // and 'JUCE_nnnnnn'. Create invisible window to handle a timer intstead.
+        // There is no need for implementing a window proc because DefWindowProc
+        // already calls the callback function when processing WM_TIMER messages.
+        constexpr size_t clsNameSz = 256;
+        fTimerWindowClassName = (LPSTR)std::malloc(clsNameSz);
+        snprintf(fTimerWindowClassName, clsNameSz, "DPF_timer_%x", std::rand());
+        WNDCLASSEX cls;
+        ZeroMemory(&cls, sizeof(cls));
+        cls.cbSize = sizeof(WNDCLASSEX);
+        cls.cbWndExtra = sizeof(LONG_PTR);
+        cls.lpszClassName = fTimerWindowClassName;
+        cls.lpfnWndProc = DefWindowProc;
+        RegisterClassEx(&cls);
+        fTimerHwnd = CreateWindowEx(0, cls.lpszClassName, "DPF Timer Helper",
+            0, 0, 0, 0, 0, HWND_MESSAGE, nullptr, nullptr, nullptr);
+        SetWindowLongPtr(fTimerHwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
+        SetTimer(fTimerHwnd, DPF_VST3_WIN32_TIMER_ID, timerFrequencyInMs,
+            static_cast<TIMERPROC>(UIVst3::nativeIdleTimerCallback));
+    }
+
+    void nativeIdleTimerDestroy()
+    {
+        KillTimer(fTimerHwnd, DPF_VST3_WIN32_TIMER_ID);
+        DestroyWindow(fTimerHwnd);
+        UnregisterClass(fTimerWindowClassName, nullptr);
+        std::free(fTimerWindowClassName);
+    }
+
+    WINAPI static void nativeIdleTimerCallback(HWND hwnd, UINT /*uMsg*/, UINT_PTR /*timerId*/,
+                                        DWORD /*dwTime*/)
+    {
+        UIVst3* ui = reinterpret_cast<UIVst3*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
+        ui->onTimer();
+    }
+# endif
+#endif
 };
 
 // --------------------------------------------------------------------------------------------------------------------
